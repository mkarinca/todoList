{"mappings":"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","sources":["./js/controller.js"],"sourcesContent":["(function (window) {\n  \"use strict\";\n\n  /**\n   * Takes a model and view and acts as the controller between them\n   *\n   * @constructor\n   * @param {object} model The model instance\n   * @param {object} view The view instance\n   */\n  function Controller(model, view) {\n    var self = this;\n    self.model = model;\n    self.view = view;\n\n    self.view.bind(\"newTodo\", function (title) {\n      self.addItem(title);\n    });\n\n    self.view.bind(\"itemEdit\", function (item) {\n      self.editItem(item.id);\n    });\n\n    self.view.bind(\"itemEditDone\", function (item) {\n      self.editItemSave(item.id, item.title);\n    });\n\n    self.view.bind(\"itemEditCancel\", function (item) {\n      self.editItemCancel(item.id);\n    });\n\n    self.view.bind(\"itemRemove\", function (item) {\n      self.removeItem(item.id);\n    });\n\n    self.view.bind(\"itemToggle\", function (item) {\n      self.toggleComplete(item.id, item.completed);\n    });\n\n    self.view.bind(\"removeCompleted\", function () {\n      self.removeCompletedItems();\n    });\n\n    self.view.bind(\"toggleAll\", function (status) {\n      self.toggleAll(status.completed);\n    });\n  }\n\n  /**\n   * Loads and initialises the view\n   *\n   * @param {string} '' | 'active' | 'completed'\n   */\n  Controller.prototype.setView = function (locationHash) {\n    var route = locationHash.split(\"/\")[1];\n    var page = route || \"\";\n    this._updateFilterState(page);\n  };\n\n  /**\n   * An event to fire on load. Will get all items and display them in the\n   * todo-list\n   */\n  Controller.prototype.showAll = function () {\n    var self = this;\n    self.model.read(function (data) {\n      self.view.render(\"showEntries\", data);\n    });\n  };\n\n  /**\n   * Renders all active tasks\n   */\n  Controller.prototype.showActive = function () {\n    var self = this;\n    self.model.read({ completed: false }, function (data) {\n      self.view.render(\"showEntries\", data);\n    });\n  };\n\n  /**\n   * Renders all completed tasks\n   */\n  Controller.prototype.showCompleted = function () {\n    var self = this;\n    self.model.read({ completed: true }, function (data) {\n      self.view.render(\"showEntries\", data);\n    });\n  };\n\n  /**\n   * An event to fire whenever you want to add an item. Simply pass in the event\n   * object and it'll handle the DOM insertion and saving of the new item.\n   */\n  Controller.prototype.addItem = function (title) {\n    var self = this;\n\n    if (title.trim() === \"\") {\n      return;\n    }\n\n    self.model.create(title, function () {\n      self.view.render(\"clearNewTodo\");\n      self._filter(true);\n    });\n  };\n\n  /*\n   * Triggers the item editing mode.\n   */\n  Controller.prototype.editItem = function (id) {\n    var self = this;\n    self.model.read(id, function (data) {\n      self.view.render(\"editItem\", { id: id, title: data[0].title });\n    });\n  };\n\n  /*\n   * Finishes the item editing mode successfully.\n   */\n  Controller.prototype.editItemSave = function (id, title) {\n    var self = this;\n\n    while (title[0] === \" \") {\n      title = title.slice(1);\n    }\n\n    while (title[title.length - 1] === \" \") {\n      title = title.slice(0, -1);\n    }\n\n    if (title.length !== 0) {\n      self.model.update(id, { title: title }, function () {\n        self.view.render(\"editItemDone\", { id: id, title: title });\n      });\n    } else {\n      self.removeItem(id);\n    }\n  };\n\n  /*\n   * Cancels the item editing mode.\n   */\n  Controller.prototype.editItemCancel = function (id) {\n    var self = this;\n    self.model.read(id, function (data) {\n      self.view.render(\"editItemDone\", { id: id, title: data[0].title });\n    });\n  };\n\n  /**\n   * By giving it an ID it'll find the DOM element matching that ID,\n   * remove it from the DOM and also remove it from storage.\n   *\n   * @param {number} id The ID of the item to remove from the DOM and\n   * storage\n   */\n  Controller.prototype.removeItem = function (id) {\n    var self = this;\n    var items;\n    self.model.read(function (data) {\n      items = data;\n    });\n\n    items.forEach(function (item) {\n      if (item.id === id) {\n        console.log(\"Element with ID: \" + id + \" has been removed.\");\n      }\n    });\n\n    self.model.remove(id, function () {\n      self.view.render(\"removeItem\", id);\n    });\n\n    self._filter();\n  };\n\n  /**\n   * Will remove all completed items from the DOM and storage.\n   */\n  Controller.prototype.removeCompletedItems = function () {\n    var self = this;\n    self.model.read({ completed: true }, function (data) {\n      data.forEach(function (item) {\n        self.removeItem(item.id);\n      });\n    });\n\n    self._filter();\n  };\n\n  /**\n   * Give it an ID of a model and a checkbox and it will update the item\n   * in storage based on the checkbox's state.\n   *\n   * @param {number} id The ID of the element to complete or uncomplete\n   * @param {object} checkbox The checkbox to check the state of complete\n   *                          or not\n   * @param {boolean|undefined} silent Prevent re-filtering the todo items\n   */\n  Controller.prototype.toggleComplete = function (id, completed, silent) {\n    var self = this;\n    self.model.update(id, { completed: completed }, function () {\n      self.view.render(\"elementComplete\", {\n        id: id,\n        completed: completed,\n      });\n    });\n\n    if (!silent) {\n      self._filter();\n    }\n  };\n\n  /**\n   * Will toggle ALL checkboxes' on/off state and completeness of models.\n   * Just pass in the event object.\n   */\n  Controller.prototype.toggleAll = function (completed) {\n    var self = this;\n    self.model.read({ completed: !completed }, function (data) {\n      data.forEach(function (item) {\n        self.toggleComplete(item.id, completed, true);\n      });\n    });\n\n    self._filter();\n  };\n\n  /**\n   * Updates the pieces of the page which change depending on the remaining\n   * number of todos.\n   */\n  Controller.prototype._updateCount = function () {\n    var self = this;\n    self.model.getCount(function (todos) {\n      self.view.render(\"updateElementCount\", todos.active);\n      self.view.render(\"clearCompletedButton\", {\n        completed: todos.completed,\n        visible: todos.completed > 0,\n      });\n\n      self.view.render(\"toggleAll\", {\n        checked: todos.completed === todos.total,\n      });\n      self.view.render(\"contentBlockVisibility\", { visible: todos.total > 0 });\n    });\n  };\n\n  /**\n   * Re-filters the todo items, based on the active route.\n   * @param {boolean|undefined} force  forces a re-painting of todo items.\n   */\n  Controller.prototype._filter = function (force) {\n    var activeRoute =\n      this._activeRoute.charAt(0).toUpperCase() + this._activeRoute.substr(1);\n\n    // Update the elements on the page, which change with each completed todo\n    this._updateCount();\n\n    // If the last active route isn't \"All\", or we're switching routes, we\n    // re-create the todo item elements, calling:\n    //   this.show[All|Active|Completed]();\n    if (\n      force ||\n      this._lastActiveRoute !== \"All\" ||\n      this._lastActiveRoute !== activeRoute\n    ) {\n      this[\"show\" + activeRoute]();\n    }\n\n    this._lastActiveRoute = activeRoute;\n  };\n\n  /**\n   * Simply updates the filter nav's selected states\n   */\n  Controller.prototype._updateFilterState = function (currentPage) {\n    // Store a reference to the active route, allowing us to re-filter todo\n    // items as they are marked complete or incomplete.\n    this._activeRoute = currentPage;\n\n    if (currentPage === \"\") {\n      this._activeRoute = \"All\";\n    }\n\n    this._filter();\n\n    this.view.render(\"setFilter\", currentPage);\n  };\n\n  // Export to window\n  window.app = window.app || {};\n  window.app.Controller = Controller;\n})(window);\n"],"names":["window","Controller","model","view","self","this","bind","title","addItem","item","editItem","id","editItemSave","editItemCancel","removeItem","toggleComplete","completed","removeCompletedItems","status","toggleAll","prototype","setView","locationHash","page","split","_updateFilterState","showAll","read","data","render","showActive","showCompleted","trim","create","_filter","slice","length","update","items","forEach","console","log","remove","silent","_updateCount","getCount","todos","active","visible","checked","total","force","activeRoute","_activeRoute","charAt","toUpperCase","substr","_lastActiveRoute","currentPage","app"],"version":3,"file":"index.904feb10.js.map"}